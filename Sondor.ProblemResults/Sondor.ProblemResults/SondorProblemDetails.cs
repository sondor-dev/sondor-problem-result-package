using Sondor.Errors.Exceptions;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;

namespace Sondor.ProblemResults;

/// <summary>
/// A machine-readable format for specifying errors in HTTP API responses based on <see href="https://tools.ietf.org/html/rfc7807"/>.
/// </summary>
public class SondorProblemDetails
{
    /// <summary>
    /// The JSON type field.
    /// </summary>
    private const string _type = "type";

    /// <summary>
    /// The JSON title field.
    /// </summary>
    private const string _title = "title";

    /// <summary>
    /// The JSON status field.
    /// </summary>
    private const string _status = "status";

    /// <summary>
    /// The JSON detail field.
    /// </summary>
    private const string _detail = "detail";

    /// <summary>
    /// The JSON instance field.
    /// </summary>
    private const string _instance = "instance";

    /// <summary>
    /// A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when
    /// dereferenced, it provides human-readable documentation for the problem type
    /// (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be
    /// "about:blank".
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyOrder(-5)]
    [JsonPropertyName(_type)]
    public string? Type { get; set; }

    /// <summary>
    /// A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence
    /// of the problem, except for purposes of localization(e.g., using proactive content negotiation;
    /// see[RFC7231], Section 3.4).
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyOrder(-4)]
    [JsonPropertyName(_title)]
    public string? Title { get; set; }

    /// <summary>
    /// The HTTP status code([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyOrder(-3)]
    [JsonPropertyName(_status)]
    public int? Status { get; set; }

    /// <summary>
    /// A human-readable explanation specific to this occurrence of the problem.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyOrder(-2)]
    [JsonPropertyName(_detail)]
    public string? Detail { get; set; }

    /// <summary>
    /// A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
    /// </summary>
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
    [JsonPropertyOrder(-1)]
    [JsonPropertyName(_instance)]
    public string? Instance { get; set; }

    /// <summary>
    /// Gets the <see cref="IDictionary{TKey, TValue}"/> for extension members.
    /// <para>
    /// Problem type definitions MAY extend the problem details object with additional members. Extension members appear in the same namespace as
    /// other members of a problem type.
    /// </para>
    /// </summary>
    /// <remarks>
    /// The round-tripping behavior for <see cref="Extensions"/> is determined by the implementation of the Input \ Output formatters.
    /// In particular, complex types or collection types may not round-trip to the original type when using the built-in JSON or XML formatters.
    /// </remarks>
    [JsonExtensionData]
    public IDictionary<string, object?> Extensions { get; set; } = new Dictionary<string, object?>(StringComparer.Ordinal);

    /// <summary>
    /// Asserts that the actual <see cref="SondorProblemDetails"/> is equal to the expected <see cref="SondorProblemDetails"/>.
    /// </summary>
    /// <param name="actual">The actual.</param>
    /// <param name="expected">The problem.</param>
    [ExcludeFromCodeCoverage]
    public static void Assert(SondorProblemDetails? actual, SondorProblemDetails? expected)
    {
        if (actual is null && expected is not null)
        {
            throw new SondorAssertionException("The provided 'actual' problem is null but was expected not to be.");
        }

        if (actual is not null && expected is null)
        {
            throw new SondorAssertionException("The provided 'actual' problem is not null but was expected not to be.");
        }

        if (actual is null || expected is null)
        {
            return;
        }

        if (!actual.Type!.Equals(expected.Type))
        {
            throw new SondorAssertionException($"The provided '{nameof(actual.Type)}' does not equal the expected. Received '{actual.Type}' but expected '{expected.Type}'.");
        }

        if (!actual.Title!.Equals(expected.Title))
        {
            throw new SondorAssertionException($"The provided '{nameof(actual.Title)}' does not equal the expected. Received '{actual.Title}' but expected '{expected.Title}'.");
        }

        if (!actual.Detail!.Equals(expected.Detail))
        {
            throw new SondorAssertionException($"The provided '{nameof(actual.Detail)}' does not equal the expected. Received '{actual.Detail}' but expected '{expected.Detail}'.");
        }

        if (!actual.Status!.Equals(expected.Status))
        {
            throw new SondorAssertionException($"The provided '{nameof(actual.Status)}' does not equal the expected. Received '{actual.Status}' but expected '{expected.Status}'.");
        }

        if (!actual.Instance!.Equals(expected.Instance))
        {
            throw new SondorAssertionException($"The provided '{nameof(actual.Instance)}' does not equal the expected. Received '{actual.Instance}' but expected '{expected.Instance}'.");
        }

        if (actual.Extensions.Count != expected.Extensions.Count)
        {
            throw new SondorAssertionException($"The provided '{nameof(actual.Extensions)}' count does not equal the expected. Received '{actual.Extensions.Count}' but expected '{expected.Extensions.Count}'.");
        }

        foreach (var kvp in actual.Extensions)
        {
            if (!expected.Extensions.TryGetValue(kvp.Key, out var expectedValue))
            {
                throw new SondorAssertionException($"The provided '{nameof(actual.Extensions)}' contains '{kvp.Key}', but the expected did not contain the key.");
            }

            if (kvp.Value?.ToString() == expectedValue?.ToString())
            {
                continue;
            }

            throw new SondorAssertionException($"The provided '{nameof(actual.Extensions)}' contains '{kvp.Key}' with a value of '{kvp.Value}' but the value was expected to be '{expectedValue}'.");
        }
    }

    /// <summary>
    /// Determines if the provided string is valid JSON for <see cref="SondorProblemDetails"/>.
    /// </summary>
    /// <param name="json">The JSON.</param>
    /// <returns>Returns true if valid JSON, otherwise false.</returns>
    public static bool IsValidJson(string json)
    {
        if (string.IsNullOrWhiteSpace(json) ||
            !(json.StartsWith("{") && json.EndsWith("}") || json.StartsWith("[") && json.EndsWith("]")))
        {
            return false;
        }

        if (JsonNode.Parse(json) is not JsonObject jObject)
        {
            return false;
        }

        string[] fields =
        [
            _type,
            _title,
            _detail,
            _status,
            _instance
        ];

        return fields.All(jObject.ContainsKey);
    }
}